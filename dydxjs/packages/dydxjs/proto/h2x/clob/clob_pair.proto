syntax = "proto3";
package h2x.clob;

import "amino/amino.proto";
import "gogoproto/gogo.proto";

option go_package = "github.com/h2x/v4-chain/protocol/x/clob/types";

// PerpetualClobMetadata contains metadata for a `ClobPair`
// representing a Perpetual product.
message PerpetualClobMetadata {
  option (amino.name) = "h2x/clob/PerpetualClobMetadata";

  // Id of the Perpetual the CLOB allows trading of.
  uint32 perpetual_id = 1;
}

// PerpetualClobMetadata contains metadata for a `ClobPair`
// representing a Spot product.
// PerpetualClobMetadata 包含 `ClobPair` 的元数据
// 代表现货产品。
message SpotClobMetadata {
  option (amino.name) = "h2x/clob/SpotClobMetadata";

  // Id of the base Asset in the trading pair.
  // 交易对中基础资产的 ID。
  uint32 base_asset_id = 1;

  // Id of the quote Asset in the trading pair.
  // 交易对中报价资产的 ID。
  uint32 quote_asset_id = 2;

  // Optional: Custodian address to receive minted base assets.
  // Empty string means no minting will occur.
  // 可选：接收mint的基础资产的托管地址。空字符串表示不mint。
  string custodian_address = 3;

  // Optional: Initial supply of base asset in quantums.
  // Empty string means no minting will occur.
  // 可选：基础资产的初始供应量（quantums）。空字符串表示不mint。
  string initial_supply = 4;
}

// ClobPair represents a single CLOB pair for a given product
// in state.
message ClobPair {
  // ID of the orderbook that stores all resting liquidity for this CLOB.
  uint32 id = 1;

  // Product-specific metadata. Perpetual CLOBs will have
  // PerpetualClobMetadata, and Spot CLOBs will have SpotClobMetadata.
  oneof metadata {
    PerpetualClobMetadata perpetual_clob_metadata = 2
        [ (amino.oneof_name) = "h2x/clob/PerpetualClobMetadata" ];
    SpotClobMetadata spot_clob_metadata = 3
        [ (amino.oneof_name) = "h2x/clob/SpotClobMetadata" ];
  }

  // Minimum increment in the size of orders on the CLOB, in base quantums.
  // Supports arbitrary precision for tokens with high decimal places (e.g., 18
  // decimals).
  bytes step_base_quantums = 4 [
    (gogoproto.customtype) =
        "github.com/h2x/v4-chain/protocol/dtypes.SerializableInt",
    (gogoproto.nullable) = false
  ];

  // Defines the tick size of the orderbook by defining how many subticks
  // are in one tick. That is, the subticks of any valid order must be a
  // multiple of this value. Generally this value should start `>= 100`to
  // allow room for decreasing it.
  uint32 subticks_per_tick = 5;

  // `10^Exponent` gives the number of QuoteQuantums traded per BaseQuantum
  // per Subtick.
  sint32 quantum_conversion_exponent = 6;

  // Status of the CLOB.
  enum Status {
    // Default value. This value is invalid and unused.
    STATUS_UNSPECIFIED = 0;
    // STATUS_ACTIVE represents an active clob pair.
    STATUS_ACTIVE = 1;
    // STATUS_PAUSED behavior is unfinalized.
    // TODO(DEC-600): update this documentation.
    STATUS_PAUSED = 2;
    // STATUS_CANCEL_ONLY behavior is unfinalized.
    // TODO(DEC-600): update this documentation.
    STATUS_CANCEL_ONLY = 3;
    // STATUS_POST_ONLY behavior is unfinalized.
    // TODO(DEC-600): update this documentation.
    STATUS_POST_ONLY = 4;
    // STATUS_INITIALIZING represents a newly-added clob pair.
    // Clob pairs in this state only accept orders which are
    // both short-term and post-only.
    STATUS_INITIALIZING = 5;
    // STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated
    // and trading has ceased. All open positions will be closed by the
    // protocol. Open stateful orders will be cancelled. Open short-term
    // orders will be left to expire.
    STATUS_FINAL_SETTLEMENT = 6;
  }

  Status status = 7;
}
