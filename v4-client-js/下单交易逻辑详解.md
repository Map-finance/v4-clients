# dYdX v4 现货下单交易逻辑详解

## 📖 目录
1. [概述](#概述)
2. [下单流程总览](#下单流程总览)
3. [核心概念解释](#核心概念解释)
4. [详细流程步骤](#详细流程步骤)
5. [价格和数量转换详解](#价格和数量转换详解)
6. [订单类型和参数](#订单类型和参数)
7. [常见问题](#常见问题)

---

## 概述

当你想要在 dYdX 上下单时，你输入的是**人类可读**的数字，比如：
- 价格：1 USDT
- 数量：1 H2

但是区块链需要的是**精确的整数**，不能有小数。所以系统需要把你输入的数字转换成区块链能理解的格式。

**简单比喻**：就像你去银行存钱，你说"存 1.5 元"，但银行系统内部可能用"150 分"来记录，这样就没有小数了。

---

## 下单流程总览

```
用户输入
  ↓
[1. 获取市场信息] ← 从 API 获取这个市场的规则
  ↓
[2. 转换价格和数量] ← 把人类可读的数字变成链上格式
  ↓
[3. 计算订单参数] ← 确定订单类型、有效期等
  ↓
[4. 构建订单消息] ← 把所有信息打包成区块链消息
  ↓
[5. 签名交易] ← 用你的私钥签名
  ↓
[6. 发送到链上] ← 提交到区块链网络
  ↓
返回交易哈希
```

---

## 核心概念解释

### 1. **Quantums（数量单位）**
- **是什么**：订单数量的链上表示
- **为什么需要**：区块链只能用整数，不能有小数
- **例子**：
  - 你输入：1 H2
  - 系统转换：1000000000000000000 quantums（假设精度是 18 位）

### 2. **Subticks（价格单位）**
- **是什么**：订单价格的链上表示
- **为什么需要**：价格也需要用整数表示
- **例子**：
  - 你输入：1 USDT
  - 系统转换：100000 subticks（根据市场规则计算）

### 3. **市场参数（Market Info）**
每个交易市场都有自己的规则，包括：
- `atomicResolution`：基础资产的小数位数（比如 H2 是 -18，表示有 18 位小数）
- `stepBaseQuantums`：最小订单数量单位
- `quantumConversionExponent`：数量转换指数
- `subticksPerTick`：最小价格单位
- `clobPairId`：这个市场的唯一 ID

### 4. **订单标志（Order Flags）**
告诉系统这是什么类型的订单：
- `SHORT_TERM`：短期订单（按区块过期）
- `LONG_TERM`：长期订单（按时间过期）
- `CONDITIONAL`：条件订单（止损/止盈）

---

## 详细流程步骤

### 步骤 1：用户调用 `placeOrder()`

**你提供的信息**：
```javascript
{
  marketId: 'H2-USDT',      // 交易对
  type: 'LIMIT',            // 订单类型：限价单
  side: 'BUY',              // 方向：买入
  price: 1,                 // 价格：1 USDT
  size: 1,                  // 数量：1 H2
  clientId: 123456,         // 订单 ID（你自己生成的）
  timeInForce: 'GTT',       // 有效期类型
  goodTilTimeInSeconds: 2419200  // 28 天后过期
}
```

### 步骤 2：获取市场信息 `retrieveMarketInfo()`

**系统做什么**：
- 检查是否已经提供了市场信息
- 如果没有，从 API 获取这个市场的参数
- 返回市场规则，比如：
  ```javascript
  {
    clobPairId: 1000000,
    atomicResolution: -18,           // H2 有 18 位小数
    stepBaseQuantums: 1000000,        // 最小订单量
    quantumConversionExponent: -9,
    subticksPerTick: 100000          // 最小价格单位
  }
  ```

**为什么需要**：不同市场有不同的规则，系统需要知道这些规则才能正确转换你的订单。

### 步骤 3：计算订单标志 `calculateOrderFlags()`

**系统做什么**：
根据订单类型和有效期类型，确定订单标志：
- `MARKET` 订单 → `SHORT_TERM`
- `LIMIT` 订单 + `GTT`（按时间过期）→ `LONG_TERM`
- `LIMIT` 订单 + 其他 → `SHORT_TERM`
- 止损/止盈订单 → `CONDITIONAL`

### 步骤 4：计算有效期 `calculateGoodTilBlock()` 或 `calculateGoodTilBlockTime()`

**系统做什么**：
- **短期订单**：计算在哪个区块过期（当前区块 + 20）
- **长期订单**：计算在哪个时间点过期（当前时间 + 你指定的秒数）

### 步骤 5：转换数量 `calculateQuantums()`

**转换公式**：
```
rawQuantums = size × 10^(-atomicResolution)
quantums = roundDown(rawQuantums, stepBaseQuantums)
finalQuantums = max(quantums, stepBaseQuantums)  // 不能小于最小值
```

**实际例子**（H2-USDT 市场）：
```
你输入：size = 1
atomicResolution = -18
stepBaseQuantums = 1000000

计算过程：
1. rawQuantums = 1 × 10^(-(-18)) = 1 × 10^18 = 1000000000000000000
2. quantums = roundDown(1000000000000000000, 1000000) = 1000000000000000000
3. finalQuantums = max(1000000000000000000, 1000000) = 1000000000000000000

结果：1000000000000000000 quantums
```

**为什么这样转换**：
- `atomicResolution = -18` 表示基础资产有 18 位小数
- 所以 1 个 H2 = 10^18 个最小单位
- 就像 1 元 = 100 分一样

### 步骤 6：转换价格 `calculateSubticks()`

**转换公式**：
```
exponent = atomicResolution - quantumConversionExponent - (-6)
rawSubticks = price × 10^exponent
subticks = roundDown(rawSubticks, subticksPerTick)
finalSubticks = max(subticks, subticksPerTick)  // 不能小于最小值
```

**实际例子**（H2-USDT 市场）：
```
你输入：price = 1
atomicResolution = -18
quantumConversionExponent = -9
subticksPerTick = 100000

计算过程：
1. exponent = -18 - (-9) - (-6) = -18 + 9 + 6 = -3
2. rawSubticks = 1 × 10^(-3) = 0.001
3. subticks = roundDown(0.001, 100000) = 0  (因为 0.001 < 100000)
4. finalSubticks = max(0, 100000) = 100000

结果：100000 subticks
```

**为什么这样转换**：
- 价格也需要转换成整数
- 如果计算出的价格小于最小单位，系统会自动提升到最小单位
- 这确保了订单价格符合市场规则

### 步骤 7：计算其他订单参数

**系统计算**：
- `orderSide`：买入还是卖出（`SIDE_BUY` 或 `SIDE_SELL`）
- `orderTimeInForce`：订单执行方式（立即成交、全部成交等）
- `clientMetadata`：订单元数据（市价单标记为 1，其他为 0）
- `conditionalType`：条件类型（普通订单为 0，止损/止盈有特殊值）
- `conditionalOrderTriggerSubticks`：触发价格（普通订单为 0）

### 步骤 8：构建订单消息 `composeMsgPlaceOrder()`

**系统做什么**：
把所有信息打包成一个订单对象：
```javascript
{
  orderId: {
    subaccountId: {
      owner: "你的地址",
      number: 0  // 子账户编号
    },
    clientId: 123456,
    orderFlags: 64,  // LONG_TERM
    clobPairId: 1000000
  },
  side: SIDE_BUY,
  quantums: 1000000000000000000,  // 转换后的数量
  subticks: 100000,               // 转换后的价格
  goodTilBlockTime: 1767151963,   // 过期时间
  timeInForce: TIME_IN_FORCE_POST_ONLY,
  reduceOnly: false,
  // ... 其他参数
}
```

### 步骤 9：签名并发送 `send()`

**系统做什么**：
1. 获取你的账户信息（账户序列号等）
2. 用你的私钥签名交易
3. 发送到区块链网络
4. 返回交易哈希

---

## 价格和数量转换详解

### 为什么需要转换？

**问题**：区块链只能处理整数，不能处理小数。

**解决方案**：使用"最小单位"的概念。

**类比**：
- 就像人民币用"分"作为最小单位，1 元 = 100 分
- 区块链用"quantum"和"subtick"作为最小单位

### 数量转换（Quantums）

**目的**：把你输入的数量（比如 1 H2）转换成链上的整数。

**关键参数**：
- `atomicResolution`：告诉你这个资产有多少位小数
  - `-18` 表示有 18 位小数
  - 就像 1 元 = 10^2 分（2 位小数）

**转换过程**：
```
输入：1 H2
↓
乘以 10^18（因为有 18 位小数）
↓
结果：1000000000000000000 quantums
```

**为什么要 round down？**
- 确保数量是 `stepBaseQuantums` 的倍数
- 比如最小单位是 1000000，那么数量必须是 1000000 的倍数

### 价格转换（Subticks）

**目的**：把你输入的价格（比如 1 USDT）转换成链上的整数。

**关键参数**：
- `atomicResolution`：基础资产的小数位数
- `quantumConversionExponent`：数量转换指数
- `subticksPerTick`：最小价格单位

**转换公式解释**：
```
exponent = atomicResolution - quantumConversionExponent - (-6)
```

这个公式考虑了：
1. 基础资产的小数位数（atomicResolution）
2. 数量转换的调整（quantumConversionExponent）
3. 报价资产的标准精度（-6，表示 USDT 有 6 位小数）

**实际例子**：
```
输入价格：1 USDT
市场参数：
  - atomicResolution = -18
  - quantumConversionExponent = -9
  - subticksPerTick = 100000

计算：
1. exponent = -18 - (-9) - (-6) = -3
2. rawSubticks = 1 × 10^(-3) = 0.001
3. 因为 0.001 < 100000（最小单位），所以提升到 100000
4. 最终：100000 subticks
```

**为什么价格会被提升？**
- 如果计算出的价格小于最小单位，系统会自动提升
- 这确保了价格符合市场的最小价格变动规则

---

## 订单类型和参数

### 订单类型（OrderType）

1. **LIMIT（限价单）**
   - 你指定价格，只有达到这个价格才成交
   - 可以设置有效期

2. **MARKET（市价单）**
   - 立即以当前市场价格成交
   - 不需要指定价格（但可以指定滑点保护价格）

3. **STOP_LIMIT（止损限价单）**
   - 当价格达到触发价格时，变成限价单
   - 需要设置触发价格和限价

4. **STOP_MARKET（止损市价单）**
   - 当价格达到触发价格时，变成市价单

5. **TAKE_PROFIT_LIMIT（止盈限价单）**
   - 当价格达到触发价格时，变成限价单

6. **TAKE_PROFIT_MARKET（止盈市价单）**
   - 当价格达到触发价格时，变成市价单

### 订单方向（OrderSide）

- **BUY**：买入
- **SELL**：卖出

### 有效期类型（TimeInForce）

1. **GTT（Good Till Time）**：按时间过期
   - 需要设置 `goodTilTimeInSeconds`
   - 用于长期订单

2. **IOC（Immediate Or Cancel）**：立即成交或取消
   - 如果不能立即成交，就取消

3. **FOK（Fill Or Kill）**：全部成交或取消
   - 必须全部成交，否则取消

4. **POST_ONLY**：只挂单，不立即成交
   - 确保你的订单成为挂单，而不是立即成交

### 订单标志（OrderFlags）

- **SHORT_TERM**：短期订单
  - 按区块过期（当前区块 + 20）
  - 用于市价单和短期限价单

- **LONG_TERM**：长期订单
  - 按时间过期
  - 用于长期限价单

- **CONDITIONAL**：条件订单
  - 需要触发条件才生效
  - 用于止损/止盈订单

---

## 常见问题

### Q1: 为什么我输入价格 1，但链上显示的是 100000？

**A**: 这是因为价格转换的结果。系统把你的价格转换成链上的最小单位（subticks）。在这个例子中：
- 你输入：1 USDT
- 系统计算后：100000 subticks
- 这是正常的，因为市场的最小价格单位是 100000 subticks

### Q2: 订单价值为什么是 100000000000000000000000？

**A**: 这是 `quantums × subticks` 的结果：
- quantums = 1000000000000000000（1 H2）
- subticks = 100000（1 USDT）
- 订单价值 = 1000000000000000000 × 100000 = 100000000000000000000000

这个数字看起来很大，但这是链上的原始值。实际价值还是 1 H2 × 1 USDT = 1 USDT。

### Q3: 为什么数量必须是 stepBaseQuantums 的倍数？

**A**: 这是市场规则。每个市场都有最小订单量，你的订单数量必须是这个最小值的整数倍。比如：
- 最小订单量 = 1000000 quantums
- 你可以下 1000000、2000000、3000000... 的订单
- 但不能下 500000 的订单（小于最小值）

### Q4: 价格为什么会被提升到 subticksPerTick？

**A**: 如果计算出的价格小于最小价格单位，系统会自动提升。这是为了：
1. 确保价格符合市场规则
2. 避免价格精度问题
3. 保证订单能够正常处理

### Q5: 订单过期时间是怎么计算的？

**A**: 
- **短期订单**：当前区块高度 + 20
- **长期订单**：当前时间（秒） + 你指定的秒数

比如你设置 `goodTilTimeInSeconds = 2419200`（28 天），系统会计算：
```
过期时间 = 当前时间戳 + 2419200 秒
```

### Q6: clientId 是什么？为什么要自己生成？

**A**: `clientId` 是你自己生成的订单 ID，用于：
1. 标识你的订单
2. 取消订单时需要用到
3. 必须是唯一的（同一个子账户内）

建议使用时间戳或随机数生成。

---

## 总结

下单流程的核心是**转换**：
1. 把你输入的人类可读数字转换成链上的整数
2. 根据市场规则调整价格和数量
3. 打包所有信息并发送到链上

**关键点**：
- 区块链只能用整数，所以需要转换
- 每个市场有自己的规则（最小数量、最小价格等）
- 系统会自动调整你的订单以符合规则
- 转换后的数字看起来很大，但实际价值不变

**记住**：你输入的是"1 H2 以 1 USDT 买入"，系统内部转换成"1000000000000000000 quantums 以 100000 subticks 买入"，但实际价值是一样的！

